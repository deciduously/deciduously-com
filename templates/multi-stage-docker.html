{#  This file was auto-generated by build.rs #}
{% extends "skel.html" %}
{% block title %}Use Multi-Stage Docker Builds For Statically-Linked Rust Binaries{% endblock %}
{% block content %}<main><p>I'm making a <a href="https://en.wikipedia.org/wiki/Static_web_page">static website</a> in <a href="https://www.rust-lang.org/">Rust</a>.  Last time I did this, I used <a href="https://www.docker.com/">Docker</a> to automate the deployment.  I was frustrated at how much bandwidth I was using shuffling around these massive build images, but the convenience was too hard to pass up and I wasn't rebuilding the image often, so just left it.</p>
<p>With this new method, my final production Docker image for the whole application is 6.85MB.  <em>I can live with that</em>.</p>
<p>I'm using <a href="https://github.com/djc/askama">Askama</a> for templating, which actually compiles your typechecked templates into your binary.  The image assets I have are all <a href="https://www.w3.org/Graphics/SVG/">SVG</a>, which is really <a href="https://en.wikipedia.org/wiki/XML">XML</a>, so I can use <a href="https://doc.rust-lang.org/std/macro.include_str.html"><code>include_str!()</code></a> for those along with things like <code>manifest.json</code> and <code>robots.txt</code> and all CSS, which includes their entire file contents directly in my compiled binary as a <code>&amp;'static str</code>.  As a result, I don't really <em>need</em> a full Rust build environment or even any asset files present to run the compiled output.</p>
<p>This time around, I did my homework and found <a href="https://alexbrand.dev/post/how-to-package-rust-applications-into-minimal-docker-containers/">this blog post</a> by <a href="https://twitter.com/alexbrand">@alexbrand</a>, which demonstrates this technique.  Instead of just bundling up with all the build dependencies in place, you can use a <a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage build</a> to generate the compiled output first and then copy it into a minimal container for distribution.  Here's my adaptation for this project:</p>
<pre><code class="language-dockerfile"># Build Stage
FROM rust:1.40.0 AS builder
WORKDIR /usr/src/
RUN rustup target add x86_64-unknown-linux-musl

RUN USER=root cargo new deciduously-com
WORKDIR /usr/src/deciduously-com
COPY Cargo.toml Cargo.lock ./
RUN cargo build --release

COPY src ./src
COPY templates ./templates
RUN cargo install --target x86_64-unknown-linux-musl --path .

# Bundle Stage
FROM scratch
COPY --from=builder /usr/local/cargo/bin/deciduously-com .
USER 1000
CMD [&quot;./deciduously-com&quot;, &quot;-a&quot;, &quot;0.0.0.0&quot;, &quot;-p&quot;, &quot;8080&quot;]
</code></pre>
<p>That's it!  The top section labelled <code>builder</code> uses the <code>rust:1.40.0</code> base image, which has everything needed to build my binary with rust.  It targets <code>x86_64-unknown-linux-musl</code>.  The <a href="https://www.musl-libc.org/">musl</a> library is an alternative <code>libc</code> designed for <a href="https://en.wikipedia.org/wiki/Static_library">static linking</a> as opposed to <a href="https://en.wikipedia.org/wiki/Dynamic_linker">dynamic</a>.  Rust has top-notch support for this (apparently).  This means the resulting binary is entirely self-contained - it has no environment requirements at all.</p>
<p>The second section, which defines the actual distribution, just starts from <a href="https://hub.docker.com/_/scratch/"><code>scratch</code></a>, not even <a href="https://www.alpinelinux.org/"><code>alpine</code></a> or whatever other minimal Docker base image I'd otherwise use.  You can use <code>COPY --from=builder</code> to reference the previous Docker stage.  This docker image has <em>nothing at all</em> in it.  This means my image really just contains my binary, no Linux userland to be found!  All with one invocation of <code>docker build</code>.</p>
<p>The middle part, with <code>cargo new</code>, makes a dummy application leveraging the docker cache for dependencies.  This means that while you're developing, subsequent runs of <code>docker build</code> won't need to rebuild every dependency in your Rust application every time, it will only rebuild what's changed just like building locally.  Marvelous!</p>
<p>I'm deploying on the DigitalOcean <a href="https://marketplace.digitalocean.com/apps/docker">One-Click Docker</a> app, which is an Ubuntu LTS image with docker pre-installed and some <a href="https://en.wikipedia.org/wiki/Uncomplicated_Firewall">UFW</a> settings preset.  This was my whole deploy process:</p>
<pre><code>$ docker build -t deciduously-com .
$ docker tag SOMETAG83979287 deciduously0/deciduously-com:latest
$ docker push deciduously0/deciduously-com:latest
$ ssh root@SOME.IP.ADDR
root@SOME.IP.ADDR# docker pull deciduously0/deciduously-com:latest
root@SOME.IP.ADDR# docker run -dit -p 80:8080 deciduously0/deciduously-com:latest
root@SOME.IP.ADDR# exit
$
</code></pre>
<p>The remote server pulls down my whopping 6.85MB image and spins it up.  I was immediately able to connect.  This minuscule image just sips at disk space, memory, and CPU, so I'm going to be able to stretch my $5/month lowest-possible-tier DigitalOcean droplet as far as it can possibly go.  The flashbacks I'm having from trying to do something similar with Clojure are terrifying...</p>
<p>Add in some scripts so you don't have to remember those commands, and my whole build and deploy process is distilled to a few keystrokes.</p>
<p>Why would I use anything else?</p>
<p>For those keeping score, yes, I've already scrapped <a href="https://dev.to/deciduously/stencil-i-think-i-found-my-frontend-home-46bf">Stencil</a> in favor of <a href="https://github.com/djc/askama">Askama</a>/<a href="https://hyper.rs/">Hyper</a>.  Within a day I had re-implemented all previous work in about a half of the code and a small fraction of the bundle size.  Yes, there's a bigger post (and GitHub template) about it brewing, and no, I'm not even sorry.  <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS</a> and all...</p>
<p><em>Photo by Richard Sagredo on Unsplash</em></p>
</main>{% endblock %}
