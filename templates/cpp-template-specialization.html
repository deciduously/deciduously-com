{#  This file was auto-generated by build.rs #}
{% extends "skel.html" %}
{% block title %}C++ Template Specialization - Syntax Note{% endblock %}
{% block content %}<main><p>I sat down yesterday with <a href="https://dev.to/codemouse92/">@codemouse92</a> via <a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare">Visual Studio Live Share</a> for <a href="https://code.visualstudio.com/">VS Code</a> -- which is an <em>awesome</em> tool - to do a mostly straightforward re-arrangement of some C++.  Unexpectedly, we ran into something, well...unexpected.  To DEV!</p>
<h2>The Concept</h2>
<p>In C++, you can write a template:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T myIdentityFunction(T val)
{
   return val;
}
</code></pre>
<p>This nearly useless function just returns whatever is passed in, no matter the type.  You use it with a concrete type, like this:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int someInt = 5;
    int aCopyOfTheSameInt = myIdentityFunction(someInt);
    std::cout &lt;&lt; aCopyOfTheSameInt &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<p>This will output 5, as expected:</p>
<pre><code class="language-cpp">$ clang++ test.cpp -o test
$ ./test
5
</code></pre>
<p>When it gets used, the compiler will generate the specialized version and insert that in your binary:</p>
<pre><code class="language-cpp">int myIdentityFunction(int val)
{
    return val;
}
</code></pre>
<p>As I just learned today, you can <a href="https://en.cppreference.com/w/cpp/language/template_specialization">specialize</a> what types end up in your templates to retain control over what the compiler will guess:</p>
<pre><code class="language-cpp">template int myIdentityFunction(int val);
</code></pre>
<p>This is a silly example, but this ability lets you do things like partially specialize a <code>template&lt;typename T, typename U&gt;</code> to <code>template&lt;int, typename U&gt;</code>, and also makes implicit behaviour explicit, giving you back the keys from the compiler.  You just define one for each type you need.</p>
<h2>The Context</h2>
<p>I don't actually know if the fact we're doing this in headers is relevant or not, but I'm including it for completeness in case somebody <em>does</em> know and wants to elaborate on this.  I think the issue is just &quot;in a class&quot; vs. &quot;not in a class&quot;.</p>
<p>We were refactoring a library to be <a href="https://en.wikipedia.org/wiki/Header-only">header-only</a>.  In a standard library, you have your declarations in <code>someModule.hpp</code>:</p>
<pre><code class="language-cpp">class idksomefunctions
{
public:
    idksomefunctions() = delete; // specify there should be no constructor

    template &lt;typename T&gt;
    static T myIdentityFunction(T);  // Template declaration
};
</code></pre>
<p>And then a corresponding <code>someModule.cpp</code> with the actual implementations and specializations:</p>
<pre><code class="language-cpp">#include &quot;someModule.hpp&quot;

template &lt;typename T&gt;
T idksomefunctions::myIdentityFunction(T val)
{
    return val;
}

// Any specializations live here
template int idksomefunctions::myIdentityFunction(int val);
</code></pre>
<p>To refactor this into a header, you just combine them both in <code>someModule.hpp</code>:</p>
<pre><code class="language-cpp">class idksomefunctions
{
public:
    idksomefunctions() = delete; // specify there should be no constructor

    template &lt;typename T&gt;
    static T myIdentityFunction(T val)
    {
        return val;
    }

    template static int myIdentityFunction(int val);  // right??
};
</code></pre>
<p>Not quite:</p>
<pre><code>$ clang++ test.cpp -o test
In file included from test.cpp:5:
./test.hpp:15:14: error: expected '&lt;' after 'template'
    template static int myIdentityFunction(int val);  // right??
             ^
1 error generated.
</code></pre>
<p>Okay, try the other syntax:</p>
<pre><code class="language-diff">-  template static int myIdentityFunction(int val);
+  template &lt;&gt; static int myIdentityFunction(int val);
</code></pre>
<p>Good to go!</p>
<h2>The Switcheroo</h2>
<p>Now, <code>idksomefunctions</code> doesn't really need to be a class - it's just, I don't know, some functions.  This could just be a <a href="https://en.cppreference.com/w/cpp/language/namespace">namespace</a>.  No more constructor thing, no more <a href="https://en.cppreference.com/w/cpp/language/static"><code>static</code></a> or <code>public</code> (or <code>storage class</code> errors), just some good ol' functions:</p>
<pre><code class="language-diff">- class idksomefunctions
+ namespace idksomefunctions
  {
-  public:
-     idksomefunctions() = delete; // specify there should be no constructor

      template &lt;typename T&gt;
-     static int myIdentityFunction(T val)
+     T myIdentityFunction(T val)
      {
          return val;
      }

      template &lt;&gt;
-     static int myIdentityFunction(int val);
+     int myIdentityFunction(int val);
  }
</code></pre>
<p>Great!  But wait:</p>
<pre><code>$ clang++ test.cpp -o test
/bin/x86_64-unknown-linux-gnu-ld: /tmp/test-d48bb0.o: in function `main':
test.cpp:(.text+0x13): undefined reference to `int idksomefunctions::myIdentityFunction&lt;int&gt;(int)'
clang-9: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>
<p>That's no good.  There's one more change to make:</p>
<pre><code class="language-diff">      template &lt;typename T&gt;
      int myIdentityFunction(int val)
      {
          return val;
      }

-     template &lt;&gt;
+     template
      int myIdentityFunction(int val);
</code></pre>
<p>Gotta take out the <code>&lt;&gt;</code> thingy, back to where we started!  Now it'll compile:</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

namespace idksomefunctions
{
    template &lt;typename T&gt;
    int myIdentityFunction(T val)
    {
        return val;
    }

    template int myIdentityFunction(int val);
};

int main()
{
    int someInt = 5;
    int aCopyOfTheSameInt = idksomefunctions::myIdentityFunction(someInt);
    std::cout &lt;&lt; aCopyOfTheSameInt &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<h2>The Recap</h2>
<p>Inside a class, you specialize via:</p>
<pre><code class="language-cpp">template&lt;&gt; static int myIdentityFunction(int val);
</code></pre>
<p>Outside of a class, though, you omit the thingy:</p>
<pre><code class="language-cpp">template int myIdentityFunction(int val);
</code></pre>
<h2>The Question</h2>
<p>What am I saying when I say <code>template &lt;&gt;</code> versus <code>template</code> here?</p>
<p><em>Photo by Ricardo Gomez Angel on Unsplash</em></p>
</main>{% endblock %}
