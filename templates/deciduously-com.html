{#  This file was auto-generated by build.rs #}
{% extends "skel.html" %}
{% block title %}I Scrapped My Stencil Project And Wrote A Static Site Instead{% endblock %}
{% block content %}<main><p>TODO MAKE A TEMPLATE APP ON GITHUB</p>
<h2>Simplicity wins</h2>
<p>In a previous post, I dramatically announced that I had <em>figured out my tool</em> for frontend:</p>
<p>POST HERE</p>
<p>I then promptly hopped ship and built a second static site generator in Rust from scratch, just like I said the whole problem was the first time.  Oops.</p>
<p>Now, in my defense, I still stand by the previous post.  That was an ankle-deep survey of the landscape, and things were rosy.  It's not accurate to say that I hopped ship immediately - I did get, like, ankle deep.  I had a 3k line codebase on my hands before hopping ship.</p>
<p>But, like, I had a 3k line codebase on my hands.</p>
<p>So, my Stencil conclusion is that it's still by a lot mny favorite tool for that kind of thing.  However, it is imperative that you fit the tool to the job.  This job just ain't it.</p>
<p>Also, <code>async</code> stabilized:</p>
<pre><code class="language-rust">pub async fn router(req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, std::convert::Infallible&gt; {
    let (method, path) = (req.method(), req.uri().path());
    info!(&quot;{} {}&quot;, method, path);
    match (method, path) {
        (&amp;Method::GET, &quot;/&quot;) | (&amp;Method::GET, &quot;/index.html&quot;) =&gt; index().await,
        (&amp;Method::GET, &quot;/cv&quot;) =&gt; cv().await,
        (&amp;Method::GET, &quot;/main.css&quot;) =&gt; {
            string_handler(include_str!(&quot;assets/main.css&quot;), &quot;text/css&quot;, None).await
        }
        (&amp;Method::GET, &quot;/manifest.json&quot;) =&gt; {
            string_handler(include_str!(&quot;assets/manifest.json&quot;), &quot;text/json&quot;, None).await
        }
        (&amp;Method::GET, &quot;/robots.txt&quot;) =&gt; {
            string_handler(include_str!(&quot;assets/robots.txt&quot;), &quot;text&quot;, None).await
        }
        (&amp;Method::GET, path_str) =&gt; image(path_str).await,
        _ =&gt; {
            warn!(&quot;{}: 404!&quot;, path);
            four_oh_four().await
        }
    }
}
</code></pre>
<p>I mean, come on.  Look at it.  Before the drop, you're working with these crazy types, that even required external crates to work at all:</p>
<pre><code class="language-rust">fn router(req: Request&lt;Body&gt;, _client: &amp;Client&lt;HttpConnector&gt;) -&gt; Box&lt;Future&lt;Item = Response&lt;Body&gt;, Error = Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; + Send&gt; {
    match (req.method(), req.uri().path()) {

        (&amp;Method::GET, &quot;/&quot;) | (&amp;Method::GET, &quot;/index.html&quot;) =&gt; index(),
        (&amp;Method::GET, &quot;/static/todo.css&quot;) =&gt; stylesheet(),
        (&amp;Method::GET, path_str) =&gt; image(path_str),
        (&amp;Method::POST, &quot;/done&quot;) =&gt; toggle_todo_handler(req),
        (&amp;Method::POST, &quot;/not-done&quot;) =&gt; toggle_todo_handler(req),
        (&amp;Method::POST, &quot;/delete&quot;) =&gt; remove_todo_handler(req),
        (&amp;Method::POST, &quot;/&quot;) =&gt; add_todo_handler(req),
        _ =&gt; four_oh_four(),
    }
}
</code></pre>
<p>No more <code>futures</code> - just use the standard language feature <code>await</code>.  This kinda changes everything for me about writing this sort of code in Rust, even thous it's really just some super convenient syntax sugar.</p>
<p>As I got deeper into my over-engineered Stencil mess and looked at what sorts of stuff was being shipped to my browser and run just to render the very simple markup and style I needed, Rust just kept looking sweeter and sweeter.</p>
<p>// XKCD gluing together stuff</p>
<p>This gives me the developer experience I wanted and nearly got with Stencil while also delivering a very simple, reliable, and fast set o' bits down the wire.</p>
<p>Who knew?</p>
<h3>Askama &gt; Components</h3>
<p>Askama is the secret sauce, here.  For a static site, most of what I want components for is dicing up markup.  I also liked the ability to use TypeScript to help make the structure of data flow between them well defined and rigid, to avoid runtime issues.</p>
<h3>Deployment</h3>
<p>Everything except images are compiled into a native binary.  Run <code>cargo build --release</code> using whatever target you need.  Run the resulting executable with the desired options!</p>
<p>I THINK IT WILL NEED IMAGE ASSETS</p>
<h3>jq</h3>
<h3>Tailwind</h3>
<h3>Config</h3>
<p>Toml scrape + Structopt  to same struct</p>
<h2>Conclusion</h2>
<p>It's just a lot more 'me' now.</p>
</main>{% endblock %}
